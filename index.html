<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stampede AI Detection — Drishti</title>
  <style>
    :root{
      --bg: #0c0c0c;
      --fg: #efefef;
      --muted: #b7b7b7;
      --accent: #ff7a18;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0}
    body{
      font-family: "IBM Plex Sans", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background:var(--bg); color:var(--fg);
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }

    /* Layout */
    .wrap{
      min-height:220vh; /* enough scrollable area */
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:28px;
      align-items:stretch;
    }

    /* Left column content */
    .left{
      padding:120px 36px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:18px;
    }
    .eyebrow{font-family:monospace; letter-spacing:.2em; color:var(--muted); font-size:13px}
    .hero{font-size:clamp(36px,6vw,72px); line-height:1; font-weight:700; margin:0}
    .desc{max-width:46ch; color:#dfe3e6}

    /* Right column: container for iframe; keep overflow visible so translateX can show outside column */
    .right{
      position:relative;
      min-height:100vh;
      overflow:visible;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:0 12px;
    }

    /* Perspective wrapper so rotateY looks 3D */
    .iframe-wrapper{
      perspective:1200px;
      -webkit-perspective:1200px;
      width:100%;
      display:flex;
      justify-content:center;
      align-items:center;
      pointer-events: none; /* wrapper itself shouldn't capture pointer; iframe will */
      overflow:visible;
    }

    /* The visible "card" that holds the iframe — this is the element we transform */
    .spline-card{
      transform-style:preserve-3d;
      will-change: transform;
      pointer-events: auto; /* allow interacting with the iframe inside */
      display:block;
      width: min(760px, 85vw);
      height: min(760px, 75vh);
      max-height: 85vh;
      border-radius:14px;
      overflow:hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6), 0 2px 10px rgba(0,0,0,0.5);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
      transition: box-shadow .2s ease;
    }

    /* The iframe itself fills the card */
    iframe.spline-frame{
      width:100%;
      height:100%;
      border:0;
      display:block;
      background:transparent;
    }

    /* Loading overlay / fallback button */
    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(0deg, rgba(0,0,0,0.45), rgba(0,0,0,0.25));
      color:var(--fg);
      font-size:15px;
      gap:12px;
      z-index:50;
    }
    .hidden{display:none}

    .btn{
      background:var(--accent);
      color:#120b04;
      padding:10px 14px;
      border-radius:10px;
      font-weight:700;
      border:0;
      cursor:pointer;
    }

    /* responsive */
    @media (max-width: 1000px){
      .wrap{grid-template-columns:1fr}
      .left{padding:56px 20px}
      .iframe-wrapper{margin-top:18px}
      .spline-card{width:90vw; height:58vh}
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="left">
      <div class="eyebrow">UNLEASH THE POWER OF</div>
      <h1 class="hero">AI Stampede<br/>Detection</h1>
      <p class="desc">Scroll to watch the mascot slide from left → right while doing a single full revolution (360°) during the scroll. If the model doesn't show, use the fallback button to open Spline in a new tab.</p>
    </section>

    <section class="right" aria-label="3D Model area">
      <div class="iframe-wrapper" aria-hidden="false">
        <!--
          Put your Spline preview URL in data-spline-base.
          Example preview link you provided:
          https://my.spline.design/genkubgreetingrobot-S1Tdjkk9fxSjcQaQzyVbZy55/
          The script below will automatically convert it to .../embed
        -->
        <div id="splineCard" class="spline-card" role="img" aria-label="Mascot 3D view">
          <iframe
            id="splineIframe"
            class="spline-frame"
            src=""
            frameborder="0"
            allow="fullscreen"
            sandbox="allow-scripts allow-same-origin allow-forms allow-popups"
            data-spline-base="https://my.spline.design/genkubgreetingrobot-S1Tdjkk9fxSjcQaQzyVbZy55/">
          </iframe>
        </div>


        
        <!-- overlay shown while loading or if embed blocked -->
        <div id="overlay" class="overlay">
          <div id="overlayText">Loading 3D scene…</div>
          <button id="openSpline" class="btn hidden">Open in new tab</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    (function () {
      const iframe = document.getElementById('splineIframe');
      const card = document.getElementById('splineCard');
      const overlay = document.getElementById('overlay');
      const overlayText = document.getElementById('overlayText');
      const openSplineBtn = document.getElementById('openSpline');

      // Get supplied base URL (preview link). If not present, fallback to current src.
      const baseUrl = iframe.dataset.splineBase || iframe.getAttribute('src') || '';

      // Compute embed URL (append '/embed' if not present)
      function toEmbedUrl(u){
        if(!u) return '';
        try {
          // remove trailing spaces
          u = u.trim();
          // if already contains '/embed' return as-is
          if(u.includes('/embed')) return u;
          // remove trailing slash then add '/embed'
          return u.replace(/\/+$/, '') + '/embed';
        } catch (e) {
          return u;
        }
      }

      const embedUrl = toEmbedUrl(baseUrl);

      // Set iframe src to embed version
      if(embedUrl) {
        iframe.src = embedUrl;
      } else {
        // no url specified — show fallback
        overlayText.textContent = "No Spline URL provided.";
        overlay.classList.remove('hidden');
        openSplineBtn.classList.remove('hidden');
        openSplineBtn.onclick = () => window.open(baseUrl || '/', '_blank');
      }

      // Loading / fallback handling:
      let didLoad = false;
      const loadTimeoutMs = 3500; // if no onload in this time, show fallback button
      let loadTimer = setTimeout(() => {
        if (!didLoad) {
          overlayText.textContent = "Embedding blocked or slow to load. Open in new tab:";
          openSplineBtn.classList.remove('hidden');
          overlay.classList.remove('hidden');
        }
      }, loadTimeoutMs);

      // on iframe load, hide overlay
      iframe.addEventListener('load', () => {
        didLoad = true;
        clearTimeout(loadTimer);
        overlay.classList.add('hidden');
      });

      // open Spline in new tab fallback
      openSplineBtn.addEventListener('click', () => {
        window.open(embedUrl || baseUrl, '_blank');
      });

      /* -------------------------
         Scroll-driven transform
         ------------------------- */

      // Range for horizontal travel in vw (left → right)
      const RANGE_VW = 20; // moves from -RANGE_VW to +RANGE_VW

      // Throttle/animation vars
      let latestScrollY = window.scrollY;
      let ticking = false;

      function onScroll() {
        latestScrollY = window.scrollY;
        requestTick();
      }

      function requestTick() {
        if (!ticking) {
          requestAnimationFrame(update);
          ticking = true;
        }
      }

      function clamp01(v){ return Math.min(Math.max(v, 0), 1); }

      function update() {
        // compute scroll percentage across the whole doc
        const docHeight = Math.max(document.documentElement.scrollHeight - window.innerHeight, 1);
        const scrollPercent = clamp01(latestScrollY / docHeight);

        // horizontal movement [-RANGE_VW .. +RANGE_VW]
        const moveX = (scrollPercent * 2 * RANGE_VW) - RANGE_VW; // in vw

        // rotate only once (0 -> 360 deg) mapped to scroll percent
        const rotationDeg = scrollPercent * 360;

        // Optionally add a subtle easing curve to rotation/movement to feel nicer:
        // For a simple ease-out feel for rotation in the middle, uncomment this line:
        // const eased = Math.sin(scrollPercent * Math.PI * 0.5); // easeOutSine
        // use eased wherever you want; below we use linear mapping as requested.

        // set transform: translateX in vw + rotateY
        card.style.transform = `translateX(${moveX}vw) rotateY(${rotationDeg}deg)`;

        ticking = false;
      }

      // initial update in case page already scrolled
      update();

      // attach listener (passive for performance)
      window.addEventListener('scroll', onScroll, { passive: true });

      // also update on resize because doc height changes
      window.addEventListener('resize', () => {
        requestTick();
      });
    })();
  </script>
</body>
</html>
